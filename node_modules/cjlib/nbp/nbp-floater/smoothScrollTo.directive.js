var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
import { Directive, Input, HostListener } from '@angular/core';
var SmoothScrollToDirective = (function () {
    function SmoothScrollToDirective() {
    }
    SmoothScrollToDirective.prototype.onClick = function () {
        this.targetElement = document.getElementById(this.scrollTo);
        if (!this.targetElement)
            return;
        var self = this;
        var _callbackBefore = this.callbackBefore;
        var callbackBefore = function (element) {
            if (_callbackBefore)
                _callbackBefore(self.scrollTo);
        };
        var _callbackAfter = this.callbackAfter;
        var callbackAfter = function (element) {
            if (_callbackAfter)
                _callbackAfter(self.scrollTo);
        };
        new SmoothScroll(this.targetElement, {
            duration: this.duration,
            offset: this.offset,
            easing: this.easing,
            callbackBefore: callbackBefore,
            callbackAfter: callbackAfter,
            containerId: this.containerId
        });
    };
    ;
    return SmoothScrollToDirective;
}());
__decorate([
    Input(),
    __metadata("design:type", Object)
], SmoothScrollToDirective.prototype, "scrollTo", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SmoothScrollToDirective.prototype, "duration", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SmoothScrollToDirective.prototype, "offset", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SmoothScrollToDirective.prototype, "easing", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SmoothScrollToDirective.prototype, "callbackBefore", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SmoothScrollToDirective.prototype, "callbackAfter", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SmoothScrollToDirective.prototype, "containerId", void 0);
__decorate([
    HostListener('click'),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], SmoothScrollToDirective.prototype, "onClick", null);
SmoothScrollToDirective = __decorate([
    Directive({
        selector: '[scrollTo]'
    })
    /**
    * SmoothScrollToDirective
    * Direttiva di controllo del movimento della pagina.
    * I suoi parametri sono:
    *	scrollTo: definisce l'Id html da raggiungere
    *	duration: durata dello scrolling;
    *	offset: offset dello spostamento;
    *	easing: tipo di movimento desiderato;
    *	callbackBefore: funzione da chiamare prima;
    *	callbackAfter: funzione da chiamare dopo;
    *
    */
    ,
    __metadata("design:paramtypes", [])
], SmoothScrollToDirective);
export { SmoothScrollToDirective };
var SmoothScroll = (function () {
    function SmoothScroll(element, options) {
        this.smoothScroll(element, options);
    }
    SmoothScroll.prototype.smoothScroll = function (element, options) {
        options = options || {};
        // Options
        var duration = options.duration || 800, offset = options.offset || 0, easing = options.easing || 'easeInOutQuart', callbackBefore = options.callbackBefore || function () { }, callbackAfter = options.callbackAfter || function () { }, container = document.getElementById(options.containerId) || null, containerPresent = (container != undefined && container != null);
        /**
         * Legge la posizione corrente
         */
        var getScrollLocation = function () {
            if (containerPresent) {
                return container.scrollTop;
            }
            else {
                if (window.pageYOffset) {
                    return window.pageYOffset;
                }
                else {
                    return document.documentElement.scrollTop;
                }
            }
        };
        /**
         * easing pattern:
         *
         * @see http://archive.oreilly.com/pub/a/server-administration/excerpts/even-faster-websites/writing-efficient-javascript.html
         */
        var getEasingPattern = function (type, time) {
            switch (type) {
                case 'easeInQuad': return time * time; // accelerating from zero velocity
                case 'easeOutQuad': return time * (2 - time); // decelerating to zero velocity
                case 'easeInOutQuad': return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration
                case 'easeInCubic': return time * time * time; // accelerating from zero velocity
                case 'easeOutCubic': return (--time) * time * time + 1; // decelerating to zero velocity
                case 'easeInOutCubic': return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration
                case 'easeInQuart': return time * time * time * time; // accelerating from zero velocity
                case 'easeOutQuart': return 1 - (--time) * time * time * time; // decelerating to zero velocity
                case 'easeInOutQuart': return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time; // acceleration until halfway, then deceleration
                case 'easeInQuint': return time * time * time * time * time; // accelerating from zero velocity
                case 'easeOutQuint': return 1 + (--time) * time * time * time * time; // decelerating to zero velocity
                case 'easeInOutQuint': return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time; // acceleration until halfway, then deceleration
                default: return time;
            }
        };
        /**
         * Calcola la distanza dello scrolling
         */
        var getEndLocation = function (element) {
            var location = 0;
            if (element.offsetParent) {
                do {
                    location += element.offsetTop;
                    element = element.offsetParent;
                } while (element);
            }
            location = Math.max(location - offset, 0);
            return location;
        };
        // Initializzazione
        setTimeout(function () {
            var currentLocation = null, startLocation = getScrollLocation(), endLocation = getEndLocation(element), timeLapsed = 0, distance = endLocation - startLocation, percentage, position, scrollHeight, internalHeight;
            /**
             * Stop l'animazione dello scrolling animation quando l'ancora è raggiunta (o  il top/bottom della pagina)
             */
            var stopAnimation = function () {
                currentLocation = getScrollLocation();
                if (containerPresent) {
                    scrollHeight = container.scrollHeight;
                    internalHeight = container.clientHeight + currentLocation;
                }
                else {
                    scrollHeight = document.body.scrollHeight;
                    internalHeight = window.innerHeight + currentLocation;
                }
                if ((position == endLocation) ||
                    (currentLocation == endLocation) ||
                    (internalHeight >= scrollHeight)) {
                    clearInterval(runAnimation);
                    callbackAfter(element);
                }
            };
            /**
             * Scroll la pagina di un incremento e controlla se è il caso di fermarsi
             */
            var animateScroll = function () {
                timeLapsed += 16;
                percentage = (timeLapsed / duration);
                percentage = (percentage > 1) ? 1 : percentage;
                position = startLocation + (distance * getEasingPattern(easing, percentage));
                if (containerPresent) {
                    container.scrollTop = position;
                }
                else {
                    window.scrollTo(0, position);
                }
                stopAnimation();
            };
            callbackBefore(element);
            var runAnimation = setInterval(animateScroll, 16);
        }, 0);
    };
    return SmoothScroll;
}());
