var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import { Subject } from 'rxjs/Subject';
import { NbpLoadingStatus } from './../nbp-commons/nbp-commons.enums';
import 'rxjs/add/operator/merge';
import 'rxjs/add/operator/delay';
import 'rxjs/add/operator/bufferWhen';
import 'rxjs/add/operator/count';
import 'rxjs/add/operator/combineLatest';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/filter';
import 'rxjs/add/operator/bufferToggle';
import 'rxjs/add/observable/interval';
var NbpPendingLoadingStatusService = (function () {
    function NbpPendingLoadingStatusService() {
        this.loadingStatusStartStream = new Subject();
        this.loadingStatusEndStream = new Subject();
    }
    NbpPendingLoadingStatusService.prototype.startLoading = function () {
        this.loadingStatusStartStream.next(NbpLoadingStatus.START);
    };
    NbpPendingLoadingStatusService.prototype.stopLoading = function () {
        this.loadingStatusEndStream.next(NbpLoadingStatus.STOP); // TaskEvents.END
    };
    NbpPendingLoadingStatusService.prototype.getPendingStatusStream = function () {
        return this.pendingStatusStream;
    };
    NbpPendingLoadingStatusService.prototype.initStreams = function (threshold) {
        var statusStartIfNotEndWithinThresholdStream = this.loadingStatusEndStream.bufferToggle(this.loadingStatusStartStream, function (value) { return Observable.interval(threshold); }) //raccogli in un buffer array gli eventi di end tra un evento di start e threshold ms dopo
            .filter(function (startEvents) { return startEvents.length == 0; }) //fai passare solo i buffer vuoti (ovvero quelli in cui non ci sono stati end nel periodo)
            .map(function (k) { return true; }); //genera l'evento di start ritardato dall' array vuoto
        // eventualmente puoi aggiungere dei logging con  .do (events => console.log(events)) intermedi per capire come funziona
        var statusEndIfNotNewStartWithinThresholdFromPreviousEndStream = this.loadingStatusStartStream.bufferToggle(this.loadingStatusEndStream, //raccogli in un buffer array gli eventi di start tra un evento di end e threshold ms dopo
        function (value) { return Observable.interval(threshold); })
            .filter(function (startEvents) { return startEvents.length == 0; }) //fai passare solo i buffer vuoti (ovvero quelli in cui non ci sono stati start nel periodo di threshold subito dopo l'end vero)
            .map(function (k) { return false; }); //genera l'evento di end ritardato solo se l'array delle start immediatamente successive all' end Ã¨ vuoto 
        this.pendingStatusStream = statusStartIfNotEndWithinThresholdStream
            .merge(statusEndIfNotNewStartWithinThresholdFromPreviousEndStream);
    };
    return NbpPendingLoadingStatusService;
}());
NbpPendingLoadingStatusService = __decorate([
    Injectable()
], NbpPendingLoadingStatusService);
export { NbpPendingLoadingStatusService };
// @Injectable()
// export class NbpPendingLoadingStatusServiceOld {
//   startIfEndNotReachedWithinThresholdEventStream: Observable<NbpLoadingStatus>;
//   withinThresholdBufferStream: Observable<NbpLoadingStatus[]>;
//   thresholdExpiredEventStream: Observable<NbpLoadingStatus>;
//   threshold = 100;
//   private loadingStatusStartStream: Subject<NbpLoadingStatus> =   new Subject<NbpLoadingStatus>();
//   private loadingStatusEndStream: Subject<NbpLoadingStatus> =   new Subject<NbpLoadingStatus>();
//   private pendingStatusStream: Observable<boolean>;
//   private scheduler: Scheduler; 
//   constructor( ) {
//     // this.initStreams(configuration); 
//     // this.initStreams(null);
//   }
//   initStreams(threshold: number): any {
//     // this.taskEventStream = this.loadingStatusEndStream.merge(this.loadingStatusStartStream);
//     this.threshold = threshold;  
//     console.log(`threshold ${this.threshold}`);
//     this.thresholdExpiredEventStream = this.loadingStatusStartStream.delay(this.threshold);
//     // { provide: SEARCH_SCHEDULER, useFactory: getTestScheduler },
//     let thresholdExpiredOrTaskEndReachedEventStream = this.thresholdExpiredEventStream.merge(this.loadingStatusEndStream);
//     this.withinThresholdBufferStream = this.loadingStatusEndStream.bufferWhen(
//                                           () => thresholdExpiredOrTaskEndReachedEventStream);
//     this.startIfEndNotReachedWithinThresholdEventStream = this.withinThresholdBufferStream
//         .filter(
//           events => events.length == 0
//         ).map( event => NbpLoadingStatus.START);
//     let notFlashingTaskEventStream = this.startIfEndNotReachedWithinThresholdEventStream
//         .merge(this.loadingStatusEndStream);
//     this.pendingStatusStream = notFlashingTaskEventStream.map( (event: NbpLoadingStatus ) => {
//       let status = event == NbpLoadingStatus.START ? true : false; 
//       return status; 
//     });
//   }
//   startLoading() {
//     this.loadingStatusStartStream.next(NbpLoadingStatus.START);
//   }
//   endCounter = 1; 
//   stopLoading() {
//     this.loadingStatusEndStream.next(this.endCounter++); // TaskEvents.END
//   }
//   getPendingStatusStream() {
//     return this.pendingStatusStream;
//   }
// }
