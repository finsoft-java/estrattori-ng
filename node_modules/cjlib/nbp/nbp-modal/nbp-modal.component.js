var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
import { Component, Input, Output, EventEmitter, Optional, ContentChild, ElementRef, KeyValueDiffers } from '@angular/core';
import { NbpSize } from './../nbp-commons/nbp-commons.enums';
import { CjErrorModalComponent } from './../../cj/cj-error-modal/cj-error-modal.component';
import { NbpAutoFocusInModalDirective } from './nbp-auto-focus-in-modal.directive';
var nextId = 0;
/**
 * La Finestra Modale è una pagina che viene visualizzata al di sopra della pagina
 * corrente, la quale viene disabilitata.
 */
var NbpModalComponent = (function () {
    function NbpModalComponent(cjErrorModal, _differs) {
        this.cjErrorModal = cjErrorModal;
        this._differs = _differs;
        this.id = "nbp-modal-" + ++nextId;
        this.nbpOpenedChange = new EventEmitter();
        /**
         * Proprietà che definisce la grandezza della modale, tramite l'enum NbpSize
         * valore di default: NbpSize.MD
         */
        this.nbpSize = NbpSize.MD;
        /**
         * Array che descrive i pulsanti
         * da visualizzare nella modale
         */
        this.nbpButtons = [];
        /**
         * Object che definisce uno stile aggiuntivo per il container di default è definito = {'max-height': '90vh'}
         */
        this.nbpContainerStyle = {};
        // /**
        //  * (Opzionale) id html dell'elemento su cui mettere il focus dopo l'apertura della modale. Deve essere unico.
        //  */
        // @Input() nbpFirstFocusElementId: string;
        /**
         * Evento lanciato alla pressione di ogni pulsante.
         * Viene passato come parametro il pulsante cliccato.
         */
        this.nbpOnButtonClicked = new EventEmitter();
        /**
         * Evento lanciato alla chusura della modale.
         */
        this.nbpOnClose = new EventEmitter();
        /**
         * Evento lanciato all'apertura della modale.
         */
        this.nbpOnOpen = new EventEmitter();
        this._modalSize = NbpSize;
        this._isModalInsideErrorModal = false;
        this._maxHeight = { 'max-height': '90vh' };
        this.buttonsNeedUpdate = false;
    }
    Object.defineProperty(NbpModalComponent.prototype, "nbpOpened", {
        /**
         * Flag che controlla la visibilità della modale.
         */
        get: function () {
            return this._nbpOpened;
        },
        set: function (nbpOpenendValue) {
            if (this._nbpOpened !== nbpOpenendValue) {
                this._nbpOpened = nbpOpenendValue;
                this.nbpOpenedChange.emit(nbpOpenendValue);
                // if  (this._nbpOpened)  {
                //     this.nbpOnOpen.emit();
                // } else {
                //      this.nbpOnClose.emit();
                // }
            }
        },
        enumerable: true,
        configurable: true
    });
    ;
    NbpModalComponent.prototype.ngOnInit = function () {
        this._evaluateButtonsAndLayout();
        this._isModalInsideErrorModal = !!this.cjErrorModal;
        this._createButtonsDiffers();
    };
    NbpModalComponent.prototype.ngOnChanges = function (changes) {
        if (changes.nbpOpened) {
            if (changes.nbpOpened.currentValue) {
                this.nbpOnOpen.emit();
                if (this.autoFocusComponent && this.autoFocusCompDOMRef) {
                    try {
                        // setto il focus su un elemento (attivando la grafica come se fosse avvenuta la pressione del tab)
                        this.setFocusOnElement();
                    }
                    catch (e) {
                        console.log('impossibile settare il flag all\'apertura della modale');
                    }
                }
            }
            else {
                // filtro il primo cambiamento (inizializzazione della modale (chiusa).
                // in questo caso voglio evitare di lanciare l'evento a vuoto.
                if (this.initialized) {
                    this.nbpOnClose.emit();
                }
                this.resetFocusOnElement();
            }
        }
        if (!this.initialized) {
            // la modale è stata inizializzata
            this.initialized = true;
        }
    };
    NbpModalComponent.prototype._populateShadowButtons = function () {
        this._shadowButtons = this.nbpButtons.length > 5 ? this.nbpButtons.slice(0, 5) : this.nbpButtons.slice();
    };
    NbpModalComponent.prototype._populateStyles = function () {
        switch (this._shadowButtons.filter(function (button) { return button.visible; }).length) {
            case 1:
                this._shadowButtons.map(function (button) {
                    button.layout = 'text-center';
                });
                break;
            case 2:
                this._shadowButtons.map(function (button, index) {
                    button.layout = 'text-center';
                });
                break;
            case 3:
                this._shadowButtons.map(function (button, index) {
                    if (index === 0) {
                        button.layout = '';
                    }
                    if (index === 1) {
                        button.layout = 'col-md-6 text-center';
                    }
                    if (index === 2) {
                        button.layout = 'text-center';
                    }
                });
                break;
            case 4:
                this._shadowButtons.map(function (button, index) {
                    button.layout = 'col-md-4 text-center';
                });
                break;
            case 5:
                this._shadowButtons.map(function (button, index) {
                    button.layout = 'col-md-offset-2 col-md-4 text-center';
                });
                break;
        }
    };
    NbpModalComponent.prototype._evaluateButtonsAndLayout = function () {
        console.log('evaluate button'); //fixme
        this._populateShadowButtons();
        this._populateStyles();
    };
    NbpModalComponent.prototype._getDisplayStyleValue = function () {
        // block => Visibile / none => Invisibile
        // let displayStyle = this._nbpOpened ? 'block' : 'none';
        // return displayStyle;
        return this._nbpOpened;
    };
    NbpModalComponent.prototype._onClick = function (button) {
        this.nbpOnButtonClicked.emit(button);
    };
    NbpModalComponent.prototype.open = function () {
        this.nbpOpened = true;
    };
    NbpModalComponent.prototype.close = function () {
        this.nbpOpened = false;
    };
    /**
     * si occupa di settare il focus sull'elemento (attivando la grafica come se fosse avvenuta la pressione del tab).
     *
     * il set del focus avviene in due fasi:
     * - si setta il focus vero e proprio all'interno del componente.
     * - si setta la grafica del componente come se si fosse settato il focus tramite tasto tab
     */
    NbpModalComponent.prototype.setFocusOnElement = function () {
        if (!this.autoFocusCompDOMRef) {
            return;
        }
        this.setInnerFocusOnElement();
        this.simulateTabFocusOnElement();
    };
    /**
     * si occupa di resettare il focus sull'elemento (necessario per far funzionare
     * il successivo set del focus all'apertura della modale).
     */
    NbpModalComponent.prototype.resetFocusOnElement = function () {
        if (!this.autoFocusCompDOMRef) {
            return;
        }
        this.resetTabFocusOnElement();
    };
    /**
     * setta il focus vero e proprio all'interno del componente.
     * Si accede all'elemento del DOM su cui è posizionata la direttiva NbpAutoFocusInModalDirective,
     * da esso si ricerca ricorsivamente nell'albero html in esso contenuto l'elemento html standard su cui settare
     * il focus.
     */
    NbpModalComponent.prototype.setInnerFocusOnElement = function () {
        var idElement = this.autoFocusCompDOMRef.nativeElement;
        if (!idElement) {
            console.warn('elemento NbpAutoFocusInModalDirective non trovato, focus non settato');
            return;
        }
        var elementToFocus = this.searchInsideComponent(idElement);
        // uso setTimeout per evitare problemi di sincronia
        setTimeout(function () {
            try {
                elementToFocus.focus();
            }
            catch (e) {
                console.warn('impossibile settare focus su componente in modale a elemento ' + elementToFocus);
                console.warn(e);
                return;
            }
        }, 0);
    };
    /**
     * questa funzione cerca nell'albero html interno al componente passato per trovare il primo elemento senza figli con
     * la proprietà tabIndex settata, nell'ipotesi che questo sia l'elemento su cui fare il focus.
     * @param {HTMLElement} idElement
     * @returns {any}
     */
    NbpModalComponent.prototype.searchInsideComponent = function (idElement) {
        if (idElement.children.length > 0) {
            for (var i = 0; i < idElement.children.length; i++) {
                // se ci sono figli vai dentro
                var child = idElement.children[i];
                var elementToFocus = this.searchInsideComponent(child);
                if (elementToFocus) {
                    // se ho trovato l'elementToFocus lo faccio risalire l'albero ricorsivo
                    return elementToFocus;
                }
            }
        }
        else {
            // se non ci sono verifica se questo elemento ha un attributo 'tabIndex'
            if (idElement.hasAttribute('tabIndex')) {
                return idElement;
            }
            else {
                return null;
            }
        }
        // ho finito i children senza trovare elementToFocus
        return null;
    };
    /**
     * questo metodo si occupa di chiamare il metodo della direttiva NbpAutoFocusInModalDirective
     * che sarà applicata sul componente su cui settare il focus. (la direttiva funge da interfaccia unica per
     * tutti i vari componenti che supportano il focus da tab)
     */
    NbpModalComponent.prototype.simulateTabFocusOnElement = function () {
        this.autoFocusComponent.setTabFocus(true);
    };
    /**
     * questo metodo si occupa di chiamare il metodo della direttiva NbpAutoFocusInModalDirective
     * che sarà applicata sul componente su cui resettare il focus. (la direttiva funge da interfaccia unica per
     * tutti i vari componenti che supportano il focus da tab)
     */
    NbpModalComponent.prototype.resetTabFocusOnElement = function () {
        this.autoFocusComponent.setTabFocus(false);
    };
    // change detection per rilevare cambiamenti negli nbpButtons (essendo un array non viene
    // rilevato dal normale ngOnChanges.
    NbpModalComponent.prototype.ngDoCheck = function () {
        var _this = this;
        this.nbpButtons.forEach(function (el) {
            if (!_this.buttonsNeedUpdate && el.id) {
                var objDiffer = _this.buttonsDiffers[el.id];
                var objChanges = objDiffer.diff(el);
                if (objChanges) {
                    _this.buttonsNeedUpdate = true;
                }
            }
        });
        if (this.buttonsNeedUpdate) {
            this._evaluateButtonsAndLayout();
            this.buttonsNeedUpdate = false;
        }
    };
    /**
     * genera un differ per confrontare i cambiamenti all'interno dell'array nbpButtons
     * @private
     */
    NbpModalComponent.prototype._createButtonsDiffers = function () {
        var _this = this;
        this.buttonsDiffers = {};
        this.nbpButtons.forEach(function (el) {
            if (el.id) {
                _this.buttonsDiffers[el.id] = _this._differs.find(el).create();
            }
            else {
                console.warn('Attenzione, change detection degli nbpButtons non funzionante nel componente nbpModal. Inserire un id unico per ogni pulsante');
            }
        });
    };
    return NbpModalComponent;
}());
__decorate([
    Input(),
    __metadata("design:type", String)
], NbpModalComponent.prototype, "id", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], NbpModalComponent.prototype, "nbpOpened", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], NbpModalComponent.prototype, "nbpOpenedChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NbpModalComponent.prototype, "nbpTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NbpModalComponent.prototype, "nbpSubTitle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], NbpModalComponent.prototype, "nbpSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NbpModalComponent.prototype, "nbpButtons", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NbpModalComponent.prototype, "nbpContainerStyle", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NbpModalComponent.prototype, "nbpOnButtonClicked", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NbpModalComponent.prototype, "nbpOnClose", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], NbpModalComponent.prototype, "nbpOnOpen", void 0);
__decorate([
    ContentChild(NbpAutoFocusInModalDirective),
    __metadata("design:type", NbpAutoFocusInModalDirective)
], NbpModalComponent.prototype, "autoFocusComponent", void 0);
__decorate([
    ContentChild(NbpAutoFocusInModalDirective, { read: ElementRef }),
    __metadata("design:type", ElementRef)
], NbpModalComponent.prototype, "autoFocusCompDOMRef", void 0);
NbpModalComponent = __decorate([
    Component({
        selector: 'nbp-modal',template: "<div class=\"nbp-modal\" [ngClass]=\"{'inside-error-modal': _isModalInsideErrorModal, 'nbp-modal--opened': nbpOpened}\"><div class=\"nbp-modal-container\" [ngStyle]=\"nbpContainerStyle\" [ngClass]=\"{'container__large': nbpSize === _modalSize.LG , 'container__medium': nbpSize === _modalSize.MD , 'container__small': nbpSize === _modalSize.SM}\"><div class=\"close-icon-container\"><span class=\"icon-times pull-right\" (click)=\"close()\"></span></div><div class=\"container-fluid\"><div class=\"row\"><div class=\"col-md-24 text-center\"><div *ngIf=\"!!nbpTitle\" class=\"col-md-24 nbp-modal-title text-center\">{{nbpTitle | uppercase}}</div><div *ngIf=\"!!nbpSubTitle\" class=\"col-md-24 nbp-modal-sub-title text-center\">{{nbpSubTitle}}</div></div></div><div class=\"row\"><div class=\"col-md-24\" [ngClass]=\"{ 'nbp-modal-body-with-title': nbpTitle, 'nbp-modal-body-without-title': !nbpTitle }\"><ng-content></ng-content></div></div><div class=\"row mrg-l-5\"><ng-container *ngFor=\"let button of _shadowButtons\"><div *ngIf=\"button.visible\" [class]=\"button.layout\"><nbp-button [nbpLabel]=\"button.label\" (nbpClick)=\"_onClick(button)\" [disabled]=\"button.disabled\" [nbpStyle]=\"button.style\" [tabindex]=\"button.tabindex || 0\"></nbp-button></div></ng-container></div></div></div></div>",
        styles: [".nbp-modal--opened{display:flex!important;flex-direction:column;align-items:center}.nbp-modal{display:none;position:fixed;z-index:10000;left:0;top:0;width:100%;height:100%;overflow:auto;background-color:rgba(0,0,0,.5)}.nbp-modal.no-static-backdrop__small{width:34.375em}.nbp-modal.container__medium{width:64em}.nbp-modal.container__large{width:85.375em}.nbp-modal.inside-error-modal{z-index:150000!important}.nbp-modal-title{color:#323232;font-size:18px;padding-top:20px}.nbp-modal-sub-title{text-transform:capitalize;color:#323232;padding-top:20px}.close-icon-container{position:relative}.close-icon-container>.icon-times{position:absolute;right:20px;top:20px;width:19px;height:19px;font-size:19px;z-index:10;color:#258900;cursor:pointer}.mrg-l-5{margin-left:5px;margin-right:5px}.nbp-modal-body-with-title{padding:20px 15px 20px 15px}.nbp-modal-body-without-title{padding:40px}.container-fluid{line-height:1}.nbp-modal-container{max-height:90vh;overflow:auto;overflow:visible;position:relative;background-color:#fefefe;margin:auto;padding-bottom:20px;border:1px solid #888}.nbp-modal-container.container__small{max-width:34.5em;min-width:17.375em}.nbp-modal-container.container__medium{max-width:64em;min-width:32em}.nbp-modal-container.container__large{max-width:85.375em;min-width:42.375em}.nbp-close-modal{color:#aaa;font-size:28px;font-weight:700}.nbp-close-modal:focus,.nbp-close-modal:hover{color:#000;text-decoration:none;cursor:pointer}:host-context(.contrasto-on) .close-icon-container>.icon-times{color:#000} /*# sourceMappingURL=nbp-modal.component.css.map */ "]
    }),
    __param(0, Optional()),
    __metadata("design:paramtypes", [CjErrorModalComponent,
        KeyValueDiffers])
], NbpModalComponent);
export { NbpModalComponent };
