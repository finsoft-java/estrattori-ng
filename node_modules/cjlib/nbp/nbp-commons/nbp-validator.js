import { Validators } from '@angular/forms';
import { Observable } from 'rxjs/Observable';
// Observable operators
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';
var normalizeValidator = function (validator) {
    var func = validator.validate.bind(validator); // estrae la funzione "validate" dalla direttiva
    if (typeof func === 'function') {
        return function (c) { return func(c); };
    }
    else {
        return validator;
    }
};
export var composeValidators = function (validators, isAsync) {
    if (isAsync === void 0) { isAsync = false; }
    if (validators == null || validators.length === 0) {
        return null;
    }
    return isAsync
        ? Validators.composeAsync(validators.map(normalizeValidator))
        : Validators.compose(validators.map(normalizeValidator));
};
export var validate = function (validators, asyncValidators) {
    return function (control) {
        var synchronousValid = function () {
            var syncValidators = composeValidators(validators);
            if (syncValidators) {
                return syncValidators(control);
            }
            else {
                return null;
            }
        };
        if (asyncValidators) {
            var asyncValidator = composeValidators(asyncValidators, true);
            // (c: AbstractControl): Promise<ValidationErrors | null> | Observable<ValidationErrors | null>;
            var asynchronousValid = asyncValidator(control);
            return asynchronousValid.map(function (v) {
                var secondary = synchronousValid();
                if (secondary || v) {
                    return Object.assign({}, secondary, v); // fixme: qui dovrebbe essere un Observalble.of(...) ? forse no. sta funzionando
                }
            });
        }
        if (validators) {
            return Observable.of(synchronousValid());
        }
        return Observable.of(null);
    };
};
/**
 * message list for standard validation error
 */
export var message = function (validator, key) {
    switch (key) {
        case 'required':
            return ' Campo obbligatorio';
        case 'pattern':
            return ' Campo non valido';
        case 'minlength':
            return ' Il campo non rispetta la lunghezza minima';
        case 'maxlength':
            return ' Il campo non rispetta la lunghezza massima';
        // modificareply
        case 'dateInvalid':
            return 'La Data non Ã¨ nel formato corretto';
    }
    switch (typeof validator[key]) {
        case 'string':
            return validator[key];
        default:
            return " Validazione fallita: " + key;
    }
};
